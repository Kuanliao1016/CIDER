View(server)
shinyApp(ui, server)
dp <- ggeffect(model_fit(), terms = term) |> as.data.frame()
model_fit <- reactive({
req(processed_data(), input$PROM_type)
df <- processed_data()
if (input$PROM_type == "continuous") {
lmer(PROM_chg_from_bl ~ PGI_C + (1 | SSID), data = df)
} else {
lmer(PROM_chg_from_bl ~ as.factor(PGI_C) + (1 | SSID), data = df)
}
})
dp <- ggeffect(model_fit(), terms = term) |> as.data.frame()
shiny::runApp(display.mode="showcase")
output$forest_plot <- renderPlot({
req(model_fit())
term <- if (input$PROM_type == "continuous") "PGI_C" else "as.factor(PGI_C)"
dp <- ggeffect(model_fit(), terms = term) |> as.data.frame()
req(!is.null(dp), nrow(dp) > 0)
# print(names(dp)) # Uncomment this line to debug column names if needed
ggplot(dp, aes(response, factor(x))) +
geom_point(color = "grey10", size = 2) +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2, color = "grey30") +
labs(x = "Predicted Change in PROM", y = "PGIâ€‘C", title = "Forest Plot") +
theme_bw() +
theme(axis.title.y = element_text(angle = 0, vjust = 0.5),
plot.title = element_text(face = "bold"))
})
runApp()
runApp()
# Generate ggeffect predictions
forest_plot_ds <- ggeffect(model_1, terms = "PGI_C") |> as.data.frame()
# Forest plot
ggplot(forest_plot_ds, aes(x = predicted, y = as.factor(x))) +
geom_point(color = "grey10", size = 2) +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2, color = "grey30") +
labs(
x = "Change in PROM from Baseline",
y = "PGI-C",
title = "Forest Plot of Expected PROM Change by PGI-C"
) +
theme_bw() +
theme(
axis.title.y = element_text(angle = 0, vjust = 0.5),
plot.title = element_text(face = "bold")
)
library(shiny)
library(dplyr)
library(lme4)
library(ggplot2)
library(ggeffects)
ui <- fluidPage(
titlePanel("PGI-C and PROM Change Analysis"),
sidebarLayout(
sidebarPanel(
fileInput("file", "Upload pgi_c.csv", accept = ".csv"),
helpText("Upload your pgi_c.csv file to begin.")
),
mainPanel(
tabsetPanel(
tabPanel("Scatter Plot", plotOutput("scatterPlot")),
tabPanel("Forest Plot", plotOutput("forestPlot")),
tabPanel("Model Summary", verbatimTextOutput("modelSummary")),
tabPanel("Coefficient Table", tableOutput("coefTable"))
)
)
)
)
server <- function(input, output, session) {
# Reactive data loading and preparation
dataInput <- reactive({
req(input$file)
pgi_c <- read.csv(input$file$datapath)
pgi_c <- pgi_c %>%
mutate(
SSID = as.factor(SSID),
time = as.integer(time),
PGI_C = as.integer(PGI_C),
PROM = as.integer(PROM)
) %>%
group_by(SSID) %>%
mutate(
baseline = PROM[time == 0],
PROM_chg_from_bl = PROM - baseline
) %>%
ungroup()
pgi_c
})
# Scatter plot with regression line
output$scatterPlot <- renderPlot({
req(dataInput())
ggplot(dataInput(), aes(x = PGI_C, y = PROM_chg_from_bl)) +
geom_point(color = "grey30") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(x = "Patient Global Impression of Change", y = "Change in PROM")
})
# Fit mixed effects model
modelFit <- reactive({
req(dataInput())
lmer(PROM_chg_from_bl ~ PGI_C + (1 | SSID), data = dataInput())
})
# Model summary
output$modelSummary <- renderPrint({
req(modelFit())
summary(modelFit())
})
# Coefficient table
output$coefTable <- renderTable({
req(modelFit())
coef_md1 <- summary(modelFit())
coefci_md1 <- confint(modelFit(), method = "boot")
data.frame(
coefficient = coef_md1$coefficients[2],
lower_ci = coefci_md1[4,1],
upper_ci = coefci_md1[4,2]
)
})
# Forest plot
output$forestPlot <- renderPlot({
req(modelFit())
forest_plot_ds <- ggeffect(modelFit(), terms = "PGI_C") |> as.data.frame()
ggplot(forest_plot_ds, aes(x = predicted, y = as.factor(x))) +
geom_point(color = "grey10", size = 2) +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2, color = "grey30") +
labs(
x = "Change in PROM from Baseline",
y = "PGI-C",
title = "Forest Plot of Expected PROM Change by PGI-C"
) +
theme_bw() +
theme(
axis.title.y = element_text(angle = 0, vjust = 0.5),
plot.title = element_text(face = "bold")
)
})
}
shinyApp(ui, server)
library(shiny)
library(dplyr)
library(lme4)
library(ggplot2)
library(ggeffects)
ui <- fluidPage(
titlePanel("PGI-C and PROM Change Analysis"),
sidebarLayout(
sidebarPanel(
fileInput("file", "Upload pgi_c.csv", accept = ".csv"),
helpText("Upload your pgi_c.csv file to begin.")
),
mainPanel(
tabsetPanel(
tabPanel("Scatter Plot", plotOutput("scatterPlot")),
tabPanel("Forest Plot", plotOutput("forestPlot")),
tabPanel("Model Summary", verbatimTextOutput("modelSummary")),
tabPanel("Coefficient Table", tableOutput("coefTable"))
)
)
)
)
server <- function(input, output, session) {
# Reactive data loading and preparation
dataInput <- reactive({
req(input$file)
pgi_c <- read.csv(input$file$datapath)
pgi_c <- pgi_c %>%
mutate(
SSID = as.factor(SSID),
time = as.integer(time),
PGI_C = as.integer(PGI_C),
PROM = as.integer(PROM)
) %>%
group_by(SSID) %>%
mutate(
baseline = PROM[time == 0],
PROM_chg_from_bl = PROM - baseline
) %>%
ungroup()
pgi_c
})
# Scatter plot with regression line
output$scatterPlot <- renderPlot({
req(dataInput())
ggplot(dataInput(), aes(x = PGI_C, y = PROM_chg_from_bl)) +
geom_point(color = "grey30") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(x = "Patient Global Impression of Change", y = "Change in PROM")
})
# Fit mixed effects model
modelFit <- reactive({
req(dataInput())
lmer(PROM_chg_from_bl ~ PGI_C + (1 | SSID), data = dataInput())
})
# Model summary
output$modelSummary <- renderPrint({
req(modelFit())
summary(modelFit())
})
# Coefficient table
output$coefTable <- renderTable({
req(modelFit())
coef_md1 <- summary(modelFit())
coefci_md1 <- confint(modelFit(), method = "boot")
data.frame(
coefficient = coef_md1$coefficients[2],
lower_ci = coefci_md1[4,1],
upper_ci = coefci_md1[4,2]
)
})
# Forest plot
output$forestPlot <- renderPlot({
req(modelFit())
# Use ggpredict as fallback if ggeffect fails
forest_plot_ds <- tryCatch({
ggeffect(modelFit(), terms = "PGI_C") |> as.data.frame()
}, error = function(e) {
ggpredict(modelFit(), terms = "PGI_C") |> as.data.frame()
})
ggplot(forest_plot_ds, aes(x = predicted, y = as.factor(x))) +
geom_point(color = "grey10", size = 2) +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2, color = "grey30") +
labs(
x = "Change in PROM from Baseline",
y = "PGI-C",
title = "Forest Plot of Expected PROM Change by PGI-C"
) +
theme_bw() +
theme(
axis.title.y = element_text(angle = 0, vjust = 0.5),
plot.title = element_text(face = "bold")
)
})
}
shinyApp(ui, server)
library(shiny)
library(dplyr)
library(lme4)
library(ggplot2)
library(ggeffects)
ui <- fluidPage(
titlePanel("PGI-C and PROM Change Analysis"),
sidebarLayout(
sidebarPanel(
fileInput("file", "Upload pgi_c.csv", accept = ".csv"),
helpText("Upload your pgi_c.csv file to begin.")
),
mainPanel(
tabsetPanel(
tabPanel("Scatter Plot", plotOutput("scatterPlot")),
tabPanel("Forest Plot", plotOutput("forestPlot")),
tabPanel("Model Summary", verbatimTextOutput("modelSummary")),
tabPanel("Coefficient Table", tableOutput("coefTable")),
tabPanel("Forest Plot Data", tableOutput("forestTable"))
)
)
)
)
server <- function(input, output, session) {
# Reactive data loading and preparation
dataInput <- reactive({
req(input$file)
pgi_c <- read.csv(input$file$datapath)
pgi_c <- pgi_c %>%
mutate(
SSID = as.factor(SSID),
time = as.integer(time),
PGI_C = as.integer(PGI_C),
PROM = as.integer(PROM)
) %>%
group_by(SSID) %>%
mutate(
baseline = PROM[time == 0],
PROM_chg_from_bl = PROM - baseline
) %>%
ungroup()
pgi_c
})
# Scatter plot with regression line
output$scatterPlot <- renderPlot({
req(dataInput())
ggplot(dataInput(), aes(x = PGI_C, y = PROM_chg_from_bl)) +
geom_point(color = "grey30") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(x = "Patient Global Impression of Change", y = "Change in PROM")
})
# Fit mixed effects model
modelFit <- reactive({
req(dataInput())
lmer(PROM_chg_from_bl ~ PGI_C + (1 | SSID), data = dataInput())
})
# Model summary
output$modelSummary <- renderPrint({
req(modelFit())
summary(modelFit())
})
# Coefficient table
output$coefTable <- renderTable({
req(modelFit())
coef_md1 <- summary(modelFit())
coefci_md1 <- confint(modelFit(), method = "boot")
data.frame(
coefficient = coef_md1$coefficients[2],
lower_ci = coefci_md1[4,1],
upper_ci = coefci_md1[4,2]
)
})
# Forest plot
output$forestPlot <- renderPlot({
req(modelFit())
# Use ggpredict as fallback if ggeffect fails
forest_plot_ds <- tryCatch({
ggeffect(modelFit(), terms = "PGI_C") |> as.data.frame()
}, error = function(e) {
ggpredict(modelFit(), terms = "PGI_C") |> as.data.frame()
})
ggplot(forest_plot_ds, aes(x = predicted, y = as.factor(x))) +
geom_point(color = "grey10", size = 2) +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2, color = "grey30") +
labs(
x = "Change in PROM from Baseline",
y = "PGI-C",
title = "Forest Plot of Expected PROM Change by PGI-C"
) +
theme_bw() +
theme(
axis.title.y = element_text(angle = 0, vjust = 0.5),
plot.title = element_text(face = "bold")
)
output$forestTable <- renderTable({
mod <- modelFit()
forest_plot_ds <- tryCatch({
ggeffect(mod, terms = "PGI_C") |> as.data.frame()
}, error = function(e) {
ggpredict(mod, terms = "PGI_C") |> as.data.frame()
})
head(forest_plot_ds, 20) # Show first 20 rows
})
})
}
shinyApp(ui, server)
forest_plot_ds <- tryCatch({
ggeffect(model_1, terms = "PGI_C") |> as.data.frame()
}, error = function(e) {
ggpredict(model_1, terms = "PGI_C") |> as.data.frame()
})
print(forest_plot_ds)
runApp()
library(shiny)
library(dplyr)
library(lme4)
library(ggplot2)
library(ggeffects)
##########ui###############
ui <- fluidPage(
titlePanel("CIDER - Clinically Important Difference Estimating and Rating using anchor-based approach"),
sidebarLayout(
sidebarPanel(
fileInput("upload", "Upload CSV File", accept = ".csv"),
radioButtons(
inputId = "PROM_type",
label = "If your PROM does not have a linear relationship with the anchor, consider treating the PROM as a categorical variable in the analysis.",
choices = c("Continuous" = "continuous", "Categorical" = "categorical"),
selected = NULL
),
radioButtons(
inputId = "Anchor_type",
label = "Is your anchor a static status (e.g.PGI-S) or global impression of change scale (e.g.PGI-C)",
choices = c("Static" = "static", "Change" = "change"),
selected = NULL
),
actionButton("run", "Run Analysis")
),
mainPanel(
plotOutput("scatter_plot"),
uiOutput("results_ui"),
plotOutput("forest_plot"),
)
)
)
###############server##########
server <- function(input, output) {
raw_data <- reactive({
req(input$upload)
read.csv(input$upload$datapath)
})
processed_data <- eventReactive(input$run, {
df <- raw_data()
df %>%
mutate(
SSID = as.factor(SSID),
time = as.integer(time),
PGI_C = as.integer(PGI_C),
PROM = as.integer(PROM)
) %>%
group_by(SSID) %>%
mutate(
baseline = PROM[time == 0],
PROM_chg_from_bl = PROM - baseline
) %>%
ungroup()
})
model_fit <- reactive({
req(processed_data(), input$PROM_type)
df <- processed_data()
if (input$PROM_type == "continuous") {
lmer(PROM_chg_from_bl ~ PGI_C + (1 | SSID), data = df)
} else {
lmer(PROM_chg_from_bl ~ as.factor(PGI_C) + (1 | SSID), data = df)
}
})
output$scatter_plot <- renderPlot({
req(processed_data())
df <- processed_data()
ggplot(df, aes(x = PGI_C, y = PROM_chg_from_bl)) +
geom_point(color = "grey30") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(x = "Patient Global Impression of Change (PGI-C)",
y = "Change in PROM from Baseline")
})
output$results_ui <- renderUI({
req(input$run, input$PROM_type == "continuous")
tagList(
h4("Estimated Coefficient and 95% CI for PGI-C"),
tableOutput("ci_table")
)
})
output$ci_table <- renderTable({
req(input$PROM_type == "continuous")
model <- model_fit()
coef_md1 <- summary(model)
coefci_md1 <- confint(model, method = "boot")
data.frame(
coefficient = coef_md1$coefficients["PGI_C", "Estimate"],
lower_ci = coefci_md1["PGI_C", 1],
upper_ci = coefci_md1["PGI_C", 2]
)
}, rownames = FALSE)
output$forest_plot <- renderPlot({
req(input$run, input$PROM_type == "continuous", model_fit())
# Try ggeffect() first, then fallback to ggpredict()
forest_plot_ds <- tryCatch({
ggeffect(model_fit(), terms = "PGI_C") |> as.data.frame()
}, error = function(e) {
ggpredict(model_fit(), terms = "PGI_C") |> as.data.frame()
})
# Ensure columns are present
if (!all(c("predicted", "conf.low", "conf.high", "x") %in% colnames(forest_plot_ds))) {
return(NULL)
}
ggplot(forest_plot_ds, aes(x = predicted, y = factor(x))) +
geom_point(color = "black", size = 2) +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2, color = "blue") +
labs(
x = "Predicted Change in PROM from Baseline",
y = "PGI-C",
title = "Forest Plot of Expected PROM Change"
) +
theme_bw()
})
}
shinyApp(ui, server)
predict(model_1)
predict(model_1, new_data = c(1,2,3,4,5,6,7))
predict(model_1, new_data = c(1,2,3,4,5,6,7))
# Create new data frame with PGI_C levels you want to predict for
new_data <- data.frame(
PGI_C = 1:7,     # or unique(your_data$PGI_C)
SSID = NA        # random effect not used in marginal predictions
)
# Predict fixed effects only (population-level)
new_data$predicted <- predict(model_1, newdata = new_data, re.form = NA)
View(new_data)
forest_plot_ds
library(boot)
# Bootstrap function
boot_fun <- function(fit) {
predict(fit, newdata = new_data, re.form = NA)
}
# Bootstrap (e.g., 1000 times)
set.seed(123)
boot_res <- bootMer(model_1, boot_fun, nsim = 1000)
# Compute 95% confidence intervals for each PGI_C level
cis <- apply(boot_res$t, 2, quantile, probs = c(0.025, 0.975))
# Add to new_data
new_data$lower_ci <- cis[1, ]
new_data$upper_ci <- cis[2, ]
View(new_data)
new_data <- new_data%>%select(-SSID)
# Forest plot
ggplot(new_data, aes(x = predicted, y = as.factor(PGI_C))) +
geom_point(color = "grey10", size = 2) +
geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 0.2, color = "grey30") +
labs(
x = "Change in PROM from Baseline",
y = "PGI-C",
title = "Forest Plot of Expected PROM Change by PGI-C"
) +
theme_bw() +
theme(
axis.title.y = element_text(angle = 0, vjust = 0.5),
plot.title = element_text(face = "bold")
)
runApp()
# Bootstrap for CI
boot_fun <- function(fit) {
predict(fit, newdata = new_data, re.form = NA)
}
install.packages('rsconnect')
install.packages("rsconnect")
shiny::runApp()
rsconnect::setAccountInfo(name='kuanliao',
token='17E921C12331CD4151982E766CC5AF61',
secret='xHpALvvwhH8y+JqLBLrLodaCthNGpwQGPtkeFC+5')
